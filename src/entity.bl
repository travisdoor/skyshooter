// Entity
EntityKind :: enum u8 {
    Player,
    Missile,
    Enemy
};

Entity :: struct {
    kind: EntityKind,
    texture: *SDL_Texture,
    position: Vec2,
    size: Vec2,
    speed: Vec2,
    dir: Vec2,
    max_speed: f32,
};

entity_init :: fn (self: *Entity,
                   game: *Game,
                   kind: EntityKind,
                   filepath: string,
                   position: *Vec2,
                   size: *Vec2,
                   max_speed: f32) {


    surface := load_surface(filepath);
    self.texture = SDL_CreateTextureFromSurface(game.renderer, surface);
    SDL_FreeSurface(surface);

    self.kind = kind;
    self.position = ^position;
    self.size = ^size;
    self.speed.x = 0.f;
    self.speed.y = 0.f;
    self.dir.x = 0.f;
    self.dir.y = 0.f;
    self.max_speed = max_speed;
};

entity_delete :: fn (self: *Entity) {
    SDL_DestroyTexture(self.texture);

    if self.kind == EntityKind.Player {
        player_terminate(cast(*Player) self);
    } else if self.kind == EntityKind.Enemy {
        enemy_terminate(cast(*Enemy) self);
    } else {
        abort();
    }
    
    free(cast(*u8) self);
};

entity_render :: fn (self: *Entity, game: *Game) {
    dst_rect := {:SDL_Rect:
        cast(s32) self.position.x,
        cast(s32) self.position.y,
        cast(s32) self.size.x,
        cast(s32) self.size.y,
    };

    SDL_RenderCopy(game.renderer, self.texture, null, &dst_rect);
};

entity_update :: fn (self: *Entity, dt: f32) {
    if self.kind == EntityKind.Player {
        player_update(cast(*Player) self, dt);
    } else if self.kind == EntityKind.Enemy {
        enemy_update(cast(*Enemy) self, dt);
    } else {
        abort();
    }

    self.position.x += self.speed.x * dt;
    self.position.y += self.speed.y * dt;
};

entity_handle_input :: fn (self: *Entity) {
    if self.kind == EntityKind.Player {
        player_handle_input(cast(*Player) self);
    }
};

// PLAYER
Player :: struct {
    base: Entity
};

player_new :: fn (game: *Game) *Entity {
    self := cast(*Player) malloc(sizeof(Player));

    initial_position := {:Vec2: 50.f, 200.f};
    size := {:Vec2: 100.f, 43.f};

    entity_init(
        cast(*Entity) self,
        game,
        EntityKind.Player,
        "data/player.png",
        &initial_position,
        &size,
        0.2f);

    return cast(*Entity) self;
};

player_terminate :: fn (self: *Player) {
};

player_update :: fn (self: *Player, dt: f32) {
    self.base.speed.x = lerp(self.base.speed.x, self.base.dir.x * self.base.max_speed, dt * 0.005f);
    self.base.speed.y = lerp(self.base.speed.y, self.base.dir.y * self.base.max_speed, dt * 0.005f);
};

player_handle_input :: fn (self: *Player) {
    if SDL_KeyPressed(SDL_Scancode.A) || SDL_KeyPressed(SDL_Scancode.LEFT)  {
        self.base.dir.x = -1.0f;
    } else if SDL_KeyPressed(SDL_Scancode.D) || SDL_KeyPressed(SDL_Scancode.RIGHT) {
        self.base.dir.x = 1.f;
    } else {
        self.base.dir.x = 0.f;
    }

    if SDL_KeyPressed(SDL_Scancode.S) || SDL_KeyPressed(SDL_Scancode.DOWN) {
        self.base.dir.y = 1.f;
    } else if SDL_KeyPressed(SDL_Scancode.W) || SDL_KeyPressed(SDL_Scancode.UP)  {
        self.base.dir.y = -1.f;
    } else {
        self.base.dir.y = 0.f;
    }
};

// ENEMY
Enemy :: struct {
    base: Entity
};

enemy_new :: fn (game: *Game, x: f32, y: f32, speed: f32) *Entity {
    self := cast(*Enemy) malloc(sizeof(Enemy));

    initial_position := {:Vec2: x, y};
    size := {:Vec2: 60.f, 85.f};

    entity_init(
        cast(*Entity) self,
        game,
        EntityKind.Enemy,
        "data/balloon.png",
        &initial_position,
        &size,
        speed);

    return cast(*Entity) self;
};

enemy_terminate :: fn (self: *Enemy) {
};

enemy_update :: fn (self: *Enemy, dt: f32) {
    self.base.speed.y = sinf(cast(f32) SDL_GetTicks() * 0.001f) * 0.05f;
    self.base.speed.x = -self.base.max_speed * dt;

    if self.base.position.x < -self.base.size.x {
        self.base.position.x = cast(f32) ScreenWidth; 
    }
};