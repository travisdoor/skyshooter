// Entity
EntityKind :: enum u8 {
    Player,
    Missile,
    Enemy
};

Entity :: struct {
    kind: EntityKind,
    texture: *SDL_Texture,
    position: Vec2,
    size: Vec2,
    destroy_anim: *Animation,
    speed: Vec2,
    dir: Vec2,
    max_speed: f32,
    alive: bool
};

entity_init :: fn (self: *Entity,
                   game: *Game,
                   kind: EntityKind,
                   texture_id: TextureId,
                   position: *Vec2,
                   size: *Vec2,
                   max_speed: f32) {

    self.texture = texture_pool_get(texture_id);
    self.kind = kind;
    self.position = ^position;
    self.size = ^size;
    self.speed.x = 0.f;
    self.speed.y = 0.f;
    self.dir.x = 0.f;
    self.dir.y = 0.f;
    self.max_speed = max_speed;
    self.alive = true;

    frames := {:iVec2: 8, 6};
    self.destroy_anim = anim_new(game, TextureId.Explosion, &frames);
};

entity_delete :: fn (self: *Entity) {
    anim_delete(self.destroy_anim);
    
    if self.kind == EntityKind.Player {
        player_terminate(cast(*Player) self);
    } else if self.kind == EntityKind.Enemy {
        enemy_terminate(cast(*Enemy) self);
    } else {
        abort();
    }
    
    free(cast(*u8) self);
};

entity_kill :: fn (self: *Entity) {
    self.alive = false;
    tmp := self.position;
    tmp.x -= self.size.x / 2.f;
    tmp.y -= self.size.y / 2.f;
    anim_play_on_position(self.destroy_anim, &tmp);
};

entity_render :: fn (self: *Entity, game: *Game) { 
    anim_render(self.destroy_anim, game);

    if !self.alive {
        return;
    }     

    dst_rect := {:SDL_Rect:
        cast(s32) self.position.x,
        cast(s32) self.position.y,
        cast(s32) self.size.x,
        cast(s32) self.size.y,
    };

    SDL_RenderCopy(game.renderer, self.texture, null, &dst_rect);
};

entity_update :: fn (self: *Entity, dt: f32) {
    anim_update(self.destroy_anim, dt);

    if !self.alive {
        return;
    }     

    if self.kind == EntityKind.Player {
        player_update(cast(*Player) self, dt);
    } else if self.kind == EntityKind.Enemy {
        enemy_update(cast(*Enemy) self, dt);
    } else {
        abort();
    }

    self.position.x += self.speed.x * dt;
    self.position.y += self.speed.y * dt;
};

entity_handle_input :: fn (self: *Entity) {
    if self.kind == EntityKind.Player {
        player_handle_input(cast(*Player) self);
    }
};

// PLAYER
Player :: struct {
    base: Entity
};

player_new :: fn (game: *Game) *Entity {
    self := cast(*Player) malloc(sizeof(Player));

    initial_position := {:Vec2: 50.f, 200.f};
    size := {:Vec2: 100.f, 43.f};

    entity_init(
        cast(*Entity) self,
        game,
        EntityKind.Player,
        TextureId.Player,
        &initial_position,
        &size,
        0.2f);

    return cast(*Entity) self;
};

player_terminate :: fn (self: *Player) {
};

player_update :: fn (self: *Player, dt: f32) {
    self.base.speed.x = lerp(self.base.speed.x, self.base.dir.x * self.base.max_speed, dt * 0.005f);
    self.base.speed.y = lerp(self.base.speed.y, self.base.dir.y * self.base.max_speed, dt * 0.005f);
};

player_handle_input :: fn (self: *Player) {
    if SDL_KeyPressed(SDL_Scancode.A) || SDL_KeyPressed(SDL_Scancode.LEFT)  {
        self.base.dir.x = -1.0f;
    } else if SDL_KeyPressed(SDL_Scancode.D) || SDL_KeyPressed(SDL_Scancode.RIGHT) {
        self.base.dir.x = 1.f;
    } else {
        self.base.dir.x = 0.f;
    }

    if SDL_KeyPressed(SDL_Scancode.S) || SDL_KeyPressed(SDL_Scancode.DOWN) {
        self.base.dir.y = 1.f;
    } else if SDL_KeyPressed(SDL_Scancode.W) || SDL_KeyPressed(SDL_Scancode.UP)  {
        self.base.dir.y = -1.f;
    } else {
        self.base.dir.y = 0.f;
    }
};

// ENEMY
Enemy :: struct {
    base: Entity,
    floating_offset: f32
};

enemy_new :: fn (game: *Game, x: f32, y: f32, speed: f32) *Entity {
    self := cast(*Enemy) malloc(sizeof(Enemy));

    initial_position := {:Vec2: x, y};
    size := {:Vec2: 60.f, 85.f};

    entity_init(
        cast(*Entity) self,
        game,
        EntityKind.Enemy,
        TextureId.Balloon,
        &initial_position,
        &size,
        speed);

    self.floating_offset = rand_range(0.f, 10.f);

    return cast(*Entity) self;
};

enemy_terminate :: fn (self: *Enemy) {
};

enemy_update :: fn (self: *Enemy, dt: f32) {
    self.base.speed.y = sinf(cast(f32) SDL_GetTicks() * 0.001f + self.floating_offset) * 0.05f;
    self.base.speed.x = -self.base.max_speed;

    if self.base.position.x < -self.base.size.x {
        self.base.position.x = cast(f32) ScreenWidth; 
    }
};