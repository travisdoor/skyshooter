LEVEL_LAYER_SKY    :: 0;
LEVEL_LAYER_HILLS  :: 1;
LEVEL_LAYER_CLOUDS :: 2;

Level :: struct {
   layers: [3]*SDL_Texture, 
   player: *Entity
};

level_new :: fn (game: *Game) *Level {
  self := cast(*Level) malloc(sizeof(Level));

  surface := load_surface("data/sky.png");
  self.layers[0] = SDL_CreateTextureFromSurface(game.renderer, surface);
  SDL_FreeSurface(surface);

  surface = load_surface("data/rocks_2.png");
  self.layers[1] = SDL_CreateTextureFromSurface(game.renderer, surface);
  SDL_FreeSurface(surface);

  surface = load_surface("data/clouds_2.png");
  self.layers[2] = SDL_CreateTextureFromSurface(game.renderer, surface);
  SDL_FreeSurface(surface);

  // init player
  tmp := {:Vec2: 50.f, 200.f};
  self.player = entity_new(game, "data/player.png", &tmp);

  return self;
};

level_delete :: fn (self: *Level) {
  loop i := 0; i < self.layers.len; i += 1 {
    SDL_DestroyTexture(self.layers[i]);
  }

  entity_delete(self.player);
  free(cast(*u8) self);
};

level_render :: fn (self: *Level, game: *Game) {
  dst_rect := {:SDL_Rect: 0, 0, 800, 600};
  src_rect : *SDL_Rect = null;

  SDL_RenderCopy(game.renderer, self.layers[LEVEL_LAYER_SKY], src_rect, &dst_rect);
  SDL_RenderCopy(game.renderer, self.layers[LEVEL_LAYER_HILLS], src_rect, &dst_rect);

  entity_render(self.player, game);

  SDL_RenderCopy(game.renderer, self.layers[LEVEL_LAYER_CLOUDS], src_rect, &dst_rect);
};

level_update :: fn (self: *Level) {
  entity_update(self.player);
};

level_handle_input :: fn (self: *Level) {
  if SDL_KeyPressed(SDL_SCANCODE_A) {
    self.player.speed.x -= 0.5f;
  }

  if SDL_KeyPressed(SDL_SCANCODE_S) {
    self.player.speed.y += 0.5f;
  }

  if SDL_KeyPressed(SDL_SCANCODE_D) {
    self.player.speed.x += 0.5f;
  }

  if SDL_KeyPressed(SDL_SCANCODE_W) {
    self.player.speed.y -= 0.5f;
  }
};