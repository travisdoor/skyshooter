LEVEL_LAYER_SKY     :: 0;
LEVEL_LAYER_HILLS1  :: 1;
LEVEL_LAYER_CLOUDS1 :: 2;
LEVEL_LAYER_HILLS2  :: 3;
LEVEL_LAYER_CLOUDS2 :: 4;
PLAYER_ID           :: cast(usize) 0;

Level :: struct {
    layers: [5]*LevelLayer,
    entities: [16]*Entity
};

LevelLayer :: struct {
    texture: *SDL_Texture,
    x_position: f32,
    x_speed: f32
};

level_new :: fn (game: *Game) *Level {
    self := cast(*Level) malloc(sizeof(Level));

    self.layers[LEVEL_LAYER_SKY] = level_layer_new(game, "data/sky.png", 0.f);
    self.layers[LEVEL_LAYER_HILLS1] = level_layer_new(game, "data/rocks_1.png", -0.05f);
    self.layers[LEVEL_LAYER_CLOUDS1] = level_layer_new(game, "data/clouds_2.png", -0.07f);
    self.layers[LEVEL_LAYER_HILLS2] = level_layer_new(game, "data/rocks_2.png", -0.09f);
    self.layers[LEVEL_LAYER_CLOUDS2] = level_layer_new(game, "data/clouds_1.png", -0.1f);

    // init player
    self.entities[PLAYER_ID] = player_new(game);

    loop i := 1; i < self.entities.len; i += 1 {
        x := rand_range(0.f, cast(f32) ScreenWidth);
        y := rand_range(0.f, cast(f32) ScreenHeight);
        speed  := rand_range(0.05f, 0.2f);

        self.entities[i] = enemy_new(game, x, y, speed);
    }

    return self;
};

level_delete :: fn (self: *Level) {
    loop i := 0; i < self.layers.len; i += 1 {
        level_layer_delete(self.layers[i]);
    }

    loop i := 0; i < self.entities.len; i += 1 {
        entity_delete(self.entities[i]);
    }

    free(cast(*u8) self);
};

level_render :: fn (self: *Level, game: *Game) {
    level_layer_render(self.layers[LEVEL_LAYER_SKY], game);
    level_layer_render(self.layers[LEVEL_LAYER_HILLS1], game);
    level_layer_render(self.layers[LEVEL_LAYER_CLOUDS1], game);
    level_layer_render(self.layers[LEVEL_LAYER_HILLS2], game);

    loop i := 0; i < self.entities.len; i += 1 {
        entity_render(self.entities[i], game);
    }

    level_layer_render(self.layers[LEVEL_LAYER_CLOUDS2], game);
};

level_update :: fn (self: *Level, dt: f32) {
    loop i := 0; i < self.entities.len; i += 1 {
        entity_update(self.entities[i], dt);
    }

    loop i := 0; i < self.layers.len; i += 1 {
        level_layer_update(self.layers[i], dt);
    }
};

level_handle_input :: fn (self: *Level) {
    loop i := 0; i < self.entities.len; i += 1 {
        entity_handle_input(self.entities[i]);
    }
};

level_layer_new :: fn (game: *Game, filename: string, x_speed: f32) *LevelLayer {
    self := cast(*LevelLayer) malloc(sizeof(LevelLayer)); 
    surface := load_surface(filename);
    self.texture = SDL_CreateTextureFromSurface(game.renderer, surface);
    SDL_FreeSurface(surface);

    self.x_position = 0.f;
    self.x_speed = x_speed;
    return self;
};

level_layer_delete :: fn (self: *LevelLayer) {
    SDL_DestroyTexture(self.texture);
    free(cast(*u8) self);
};

level_layer_render :: fn (self: *LevelLayer, game: *Game) {
    ipos := cast(s32) roundf(self.x_position);

    dst_rect := {:SDL_Rect:
        ipos,
        0,
        ScreenWidth,
        ScreenHeight
    };

    SDL_RenderCopy(game.renderer, self.texture, null, &dst_rect);

    dst_rect.x += ScreenWidth;
    SDL_RenderCopy(game.renderer, self.texture, null, &dst_rect);
};

level_layer_update :: fn (self: *LevelLayer, dt: f32) {
    self.x_position += self.x_speed * dt;
    if self.x_position < -(cast(f32) ScreenWidth) { self.x_position = 0.f; }
};